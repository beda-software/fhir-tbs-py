import fhirpy_types_r5 as r5
from fhirpy import AsyncFHIRClient
from pydantic import BaseModel

from fhir_tbs.utils import extract_relative_reference

from .implementation import AbstractTBS
from .types import (
    SubscriptionDefinitionPrepared,
    SubscriptionEvent,
    SubscriptionInfo,
)


class R5TBS(AbstractTBS[r5.Subscription, r5.AnyResource]):
    @classmethod
    async def fetch_subscription(
        cls: type["R5TBS"], fhir_client: AsyncFHIRClient, webhook_url: str
    ) -> r5.Subscription | None:
        return await fhir_client.resources(r5.Subscription).search(url=webhook_url).first()

    @classmethod
    async def fetch_subscription_events(
        cls: type["R5TBS"],
        fhir_client: AsyncFHIRClient,
        subscription: r5.Subscription,
        since: int | None,
        until: int | None,
    ) -> list[SubscriptionEvent[r5.AnyResource]]:
        bundle_data = await fhir_client.execute(
            f"Subscription/{subscription.id}/$events",
            method="GET",
            params={"eventsSinceNumber": since, "eventsUntilNumber": until},
        )
        return cls.extract_subscription_events_from_bundle(bundle_data)

    @classmethod
    def extract_subscription_info(
        cls: type["R5TBS"], subscription: r5.Subscription
    ) -> SubscriptionInfo:
        token = None
        parameters = subscription.parameter or []
        for parameter in parameters:
            if parameter.name.lower() == "x-api-key":
                token = parameter.value

        return {"status": subscription.status, "token": token}

    @classmethod
    def extract_subscription_events_from_bundle(
        cls: type["R5TBS"],
        bundle_data: dict,
    ) -> list[SubscriptionEvent[r5.AnyResource]]:
        notification_bundle = r5.Bundle(**bundle_data)
        _extract_relative_references_recursive(notification_bundle)
        assert notification_bundle.entry
        assert notification_bundle.entry[0]
        assert notification_bundle.entry[0].resource
        subscription_status = notification_bundle.entry[0].resource
        assert isinstance(subscription_status, r5.SubscriptionStatus)

        included_resources_by_reference = {
            f"{entry.resource.resourceType}/{entry.resource.id}": entry.resource
            for entry in notification_bundle.entry[1:]
            if entry.resource
        }

        subscription_events: list[SubscriptionEvent[r5.AnyResource]] = []

        for event in subscription_status.notificationEvent or []:
            if not event.focus or not event.focus.reference:
                continue
            focus_reference = event.focus.reference
            context_references = [
                ctx.reference for ctx in (event.additionalContext or []) if ctx.reference
            ]

            subscription_events.append(
                {
                    "reference": focus_reference,
                    "included_resources": [
                        included_resources_by_reference[reference]
                        for reference in [*context_references, focus_reference]
                        if reference in included_resources_by_reference
                    ],
                    "timestamp": event.timestamp,
                    "event_number": int(event.eventNumber),
                }
            )

        return subscription_events

    @classmethod
    def build_subscription(
        cls: type["R5TBS"],
        webhook_id: str,
        webhook_url: str,
        webhook_token: str | None,
        subscription: SubscriptionDefinitionPrepared[r5.AnyResource],
    ) -> r5.Subscription:
        return r5.Subscription(
            status="requested",
            reason=f"Autogenerated subscription for {webhook_id}",
            topic=subscription["topic"],
            channelType=r5.Coding(
                system="http://terminology.hl7.org/CodeSystem/subscription-channel-type",
                code="rest-hook",
            ),
            content=subscription["payload_content"],
            # maxCount must be 1
            maxCount=1,
            heartbeatPeriod=subscription["heartbeat_period"],
            timeout=subscription["timeout"],
            endpoint=webhook_url,
            parameter=[r5.SubscriptionParameter(name="X-Api-Key", value=webhook_token)]
            if webhook_token
            else [],
            filterBy=[
                r5.SubscriptionFilterBy(
                    resourceType=filter_by["resource_type"],
                    filterParameter=filter_by["filter_parameter"],
                    comparator=filter_by.get("comparator"),
                    modifier=filter_by.get("modifier"),
                    value=filter_by["value"],
                )
                for filter_by in subscription["filter_by"]
            ],
        )


def _extract_relative_references_recursive(instance: BaseModel) -> BaseModel:
    if isinstance(instance, r5.Reference) and instance.reference:
        instance.reference = extract_relative_reference(instance.reference)

        return instance

    for field_name in instance.model_fields:
        field_value = getattr(instance, field_name)
        if isinstance(field_value, list):
            for sub_field in field_value:
                _extract_relative_references_recursive(sub_field)
        if isinstance(field_value, BaseModel):
            _extract_relative_references_recursive(field_value)

    return instance
